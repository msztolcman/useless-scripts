#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Simple utility to calculate different types of hashes from given files/data
"""

from __future__ import print_function, unicode_literals

import argparse
import hashlib
import os
import sys

__version__ = 'version 0.2'
__author__ = 'Marcin Sztolcman <marcin@urzenia.net>'
__copyright__ = '(r) 2012'
__program__ = 'hashfile - calculate hash of given files'
__date__ = '2012-05-22'
__license__ = 'GPL v.2'

__desc__ = '''%(desc)s
%(author)s %(copyright)s
license: %(license)s
version %(version)s (%(date)s)''' % {
  'desc': __program__,
  'author': __author__,
  'copyright': __copyright__,
  'license': __license__,
  'version': __version__,
  'date': __date__
}

MAX_INPUT_READ = 4*1024**2
DEFAULT_ALGORITHM = 'sha1'


# pylint: disable=missing-docstring
def _get_available_algorithms():
    try:
        available = hashlib.algorithms_available
    except AttributeError:
        try:
            available = set(hashlib.algorithms)
        except AttributeError:
            available = {'md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'}

    aliases = {
        'sha1': {'DSA', 'DSA-SHA', 'dsaEncryption', 'dsaWithSHA', 'ecdsa-with-SHA1'}
    }

    for name in aliases:
        if name in available:
            available -= aliases[name]

    to_remove = set()
    for algo in available:
        lowered = algo.lower()
        if algo != lowered and lowered in available:
            to_remove.add(algo)

    available -= to_remove

    result = list(available)
    result.sort()
    return result

AVAILABLE_ALGORITHMS = _get_available_algorithms()


def hash_file(file_path, algo='sha1', max_input_read=4*1024**2):
    """
    Calculate hash
    :param file_path: path or '-' for STDIN
    :param algo:
    :param max_input_read:
    :return:
    """
    hasher = hashlib.new(algo)

    fh = open(file_path, 'rb') if file_path != '-' else sys.stdin
    while True:
        data = fh.read(max_input_read)
        if not len(data):
            break

        hasher.update(data)

    if file_path == '-':
        fh.close()

    return hasher


# pylint: disable=missing-docstring
def main():
    parser = argparse.ArgumentParser(description='Calculate hash of some files',
        epilog='Algorithm can be also set from program name (for example call program as sha1 to use sha1 algorithm)')
    parser.add_argument('-a', '--algorithm', default=[], action='append', choices=AVAILABLE_ALGORITHMS,
        help='algorithm used to calculate hash '
             'If given more then one, then use different algorithms for different files (use first algo to first '
             'file, second algo to second file etc. If there is more files then algorithms, last algorithm from '
             'list is used.')
    parser.add_argument('--max-input-read', default=MAX_INPUT_READ,
        help='maximum data size for read at once')
    parser.add_argument('files', metavar='file', type=str, nargs='*',
        help='list of files (stdin by default)')

    args = parser.parse_args()

    if len(args.algorithm) > 0:
        algorithms = args.algorithm
    elif os.path.basename(sys.argv[0]) in AVAILABLE_ALGORITHMS:
        algorithms = [os.path.basename(sys.argv[0]), ]
    else:
        algorithms = [DEFAULT_ALGORITHM, ]

    filenames = args.files or ['-', ]
    for i, filename in enumerate(filenames):
        algo = algorithms[i] if len(algorithms) > i else algorithms[-1]
        try:
            filehash = hash_file(filename, algo=algo, max_input_read=args.max_input_read)
        except (OSError, IOError) as exc:
            print('ERROR: %s %s' % (filename, str(exc)), file=sys.stderr)
        else:
            print('%s: %s %s' % (algo, filehash.hexdigest(), filename))

if __name__ == '__main__':
    main()
